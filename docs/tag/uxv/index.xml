<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>UxV | Rapid Control Prototyping</title><link>https://lubin.kerhuel.eu/tag/uxv/</link><atom:link href="https://lubin.kerhuel.eu/tag/uxv/index.xml" rel="self" type="application/rss+xml"/><description>UxV</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Mon, 01 Jul 2019 00:00:00 +0000</lastBuildDate><image><url>https://lubin.kerhuel.eu/media/icon_hu_7804b255830ce5f.png</url><title>UxV</title><link>https://lubin.kerhuel.eu/tag/uxv/</link></image><item><title>UxV toolbox</title><link>https://lubin.kerhuel.eu/uxv/</link><pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate><guid>https://lubin.kerhuel.eu/uxv/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The UxV toolbox for Matlab/Simulink provides Matlab scripts and simulink blocks for UAVs to handle MAVLink protocol, GPS, RC receivers and telemetry protocols.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matlab script for post flight data analyses (MAVLink).&lt;/li&gt;
&lt;li&gt;Simulink blocks for autopilote model based design (Rapid Control Prototyping using Simulink)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This model-based design and analysis tools speed-up the back and forth between experimental tests and simulation.&lt;/p&gt;
&lt;h2 id="matlab-scripts-for-mavlink"&gt;Matlab scripts for MAVLink&lt;/h2&gt;
&lt;p&gt;Three main scripts enable decoding MAVLink messages, creating simulink model for simulation based on logged data, and generating map trajectory trace from GPS messages.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Script&lt;/th&gt;
&lt;th&gt;Input&lt;/th&gt;
&lt;th&gt;Output&lt;/th&gt;
&lt;th&gt;Function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;(1) &lt;em&gt;mavlink2mat&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;Mavlink log&lt;/td&gt;
&lt;td&gt;.mat&lt;/td&gt;
&lt;td&gt;matlab analysis&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(2) &lt;em&gt;mavlink2simulink&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;Mavlink log&lt;/td&gt;
&lt;td&gt;.mat / .mdl (.slx)&lt;/td&gt;
&lt;td&gt;simulation based on real data&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(3) &lt;em&gt;mavlink2kml&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;Mavlink log&lt;/td&gt;
&lt;td&gt;.kml&lt;/td&gt;
&lt;td&gt;plot GPS trace(s) on a map&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;mavlink2gui&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;Mavlink log&lt;/td&gt;
&lt;td&gt;GUI&lt;/td&gt;
&lt;td&gt;graphical exploration of mavlink log&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;mavlinkgui&lt;/em&gt; script opens a Graphical User Interface to explore MAVLink data. It list MAVLink messages found in a log file and plot selected {message - value}. Plot script is customizable enabling user to go beyond a simple plot. The GUI provides access to the three scripts mentioned above.&lt;/p&gt;
&lt;h2 id="simulink-blocks"&gt;Simulink blocks&lt;/h2&gt;
&lt;p&gt;10 added blocks add essential UAV features to implement an autopilot on a dsPIC DSC. These blocks complete the MPLAB blocks for Simulink from Microchip providing peripheral blocks for code generation. These work on top of the MathWorks Embedded Coder. Added features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPS
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;GPS Parser&lt;/em&gt; to decode NMEA messages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MATH
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Quaternion to Cardan FxPt&lt;/em&gt; to convert quaternion angle to Cardan angle in fixed point (similar to euler)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MAVLink:
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;SEND&lt;/em&gt; (send a message)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RECEIVE&lt;/em&gt; (Receive a message)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;MAVLink Data&lt;/em&gt; (Way Points data)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;MAVLink Parser&lt;/em&gt; (decode input message and implement WayPoint&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt; and Parameter&lt;sup id="fnref:2"&gt;&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref"&gt;2&lt;/a&gt;&lt;/sup&gt; protocols)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="block-receiver-telemetry"&gt;Receivers-Telemetry&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;S.BUS&lt;/em&gt; receive RC channels&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Smart Port&lt;/em&gt; send telemetry values&lt;/li&gt;
&lt;li&gt;&lt;em&gt;F.Port&lt;/em&gt; receive RC channels + send telemetry&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Sensor for Smart.Port or F.Port&lt;/em&gt; set values to send over telemetry&lt;sup id="fnref:3"&gt;&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Except the MATH block, these blocks are typically connected to the dsPIC UART Rx/Tx block to send/receive the data flow from a GPS, a receiver, a radio link.&lt;/p&gt;
&lt;h2 id="installation"&gt;Installation&lt;/h2&gt;
&lt;p&gt;These blocks are developed by Lubin Kerhuel and distributed for free with the &lt;a href="https://www.mathworks.com/matlabcentral/fileexchange/71892-mplab-device-blocks-for-simulink" target="_blank" rel="noopener"&gt;MPLAB device blocks for Simulink&lt;/a&gt; from Microchip.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install the MPLAB Device Blocks for Microchip&lt;/li&gt;
&lt;li&gt;type &lt;em&gt;pinInfo&lt;/em&gt;, click on &lt;em&gt;go to Third Part Tools folder&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Start script &lt;em&gt;UxV_Blockset_Installer.p&lt;/em&gt; in the UxV_blockset folder.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;em&gt;Way Point protocol&lt;/em&gt; allows setting and reading WayPoint from a MAVLink compatible ground station.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;em&gt;Parameter protocol&lt;/em&gt; enable tuning from any MAVLink ground station the Simulink tunable parameters which are normally tuned with External Mode or from the Processor In the Loop simulation (PIL).&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;&lt;em&gt;Sensor for Smart.Port or F.Port&lt;/em&gt; block is used with either the &lt;em&gt;Smart Port&lt;/em&gt; of the &lt;em&gt;F.Port&lt;/em&gt; block. These protocols allow sending telemetry packets back to the Remote Controller (RC) interface. It enables emulation of Frsky sensor (battery voltage and current, variometer, airspeed, GPS) adding features to your remote easily. They also enable emulation of BetaFlight telemetry. Used with LUA script, this adds features like artificial horizon, air speed, vertical speed, distance from home and many others to your remote (tested with &lt;a href="https://github.com/yaapu/FrskyTelemetryScript/wiki" target="_blank" rel="noopener"&gt;yaapu LUA scripts&lt;/a&gt;).&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description></item><item><title>block receiver &amp; telemetry: S.BUS, Smart Port, F.Port</title><link>https://lubin.kerhuel.eu/uxv/block-receiver-telemetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lubin.kerhuel.eu/uxv/block-receiver-telemetry/</guid><description>&lt;!-- Enable Photo Swipe + gallery features --&gt;
&lt;p&gt;Three blocks add support for three protocol found in receivers. Traditional PWM output receiver can be handled directly through the Input Capture or Change Notification peripheral and do not required a specific block.&lt;/p&gt;
&lt;h2 id="sbus-smart-port-and-fport"&gt;S.BUS, Smart Port and F.Port&lt;/h2&gt;
&lt;p&gt;S.BUS, Smart Port (also named S.Port) and F.Port are three protocol available in FrSky RC receiver and compatible. All three protocol rely on the UART peripheral with different settings. Their purpose is specific:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S.BUS&lt;/strong&gt; is a unidirectional protocol from the receiver to an external device to provide channels values and RSSI&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt; (i.e. radio link quality).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smart Port (S.Port)&lt;/strong&gt; is a bidirectional protocol. The receiver ping for various connected sensors and retrieve measurements to send through telemetry to the remote control.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F.Port&lt;/strong&gt; is a bidirectional protocol where the receiver communicate channels values and RSSI, and get values from connected sensors to send through telemetry to the remote control.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The two bidirectional protocol &lt;em&gt;Smart Port&lt;/em&gt; and &lt;em&gt;F.Port&lt;/em&gt; use one single wire for Tx and Rx. Communication is done in Half duplex mode.&lt;/p&gt;
&lt;p&gt;FrSky receiver have two variants: (model shipped with Smart port: x4r, rx4r, x6r, s6r, rx6r, x8r, s8r, xsr, xsr-m, r-xsr &amp;hellip;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;S.Bus &amp;amp; Smart Port&lt;/strong&gt; (stock), available on two distinct three pins ports&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F.Port&lt;/strong&gt; available on one replaced Smart Port three pin port&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Stock receiver have two ports: S.BUS and Smart Port. This is changed for a unique F.Port by flashing an alternative firmware provided by &lt;a href="https://www.frsky-rc.com/" target="_blank" rel="noopener"&gt;FrSky&lt;/a&gt;. The alternative firmware remove the S.BUS port and convert the Smart Port to an F.Port.&lt;/p&gt;
&lt;h3 id="uart-settings-and-implementation"&gt;UART settings and implementation&lt;/h3&gt;
&lt;p&gt;S.BUS, S.Port and F.Port have different UART setting defined in the table:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style="text-align: center"&gt;Baudrate&lt;/th&gt;
&lt;th style="text-align: center"&gt;Duplex&lt;/th&gt;
&lt;th style="text-align: center"&gt;Logic&lt;/th&gt;
&lt;th style="text-align: center"&gt;parity&lt;/th&gt;
&lt;th style="text-align: center"&gt;stop-bit&lt;/th&gt;
&lt;th style="text-align: center"&gt;flow-ctrl&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;S.BUS&lt;/td&gt;
&lt;td style="text-align: center"&gt;100000&lt;/td&gt;
&lt;td style="text-align: center"&gt;Rx only&lt;/td&gt;
&lt;td style="text-align: center"&gt;3.3V inverted&lt;/td&gt;
&lt;td style="text-align: center"&gt;even&lt;/td&gt;
&lt;td style="text-align: center"&gt;2&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart Port&lt;/td&gt;
&lt;td style="text-align: center"&gt;57600&lt;/td&gt;
&lt;td style="text-align: center"&gt;&lt;strong&gt;Half&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: center"&gt;3.3V inverted&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;td style="text-align: center"&gt;1&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F.Port&lt;/td&gt;
&lt;td style="text-align: center"&gt;115200&lt;/td&gt;
&lt;td style="text-align: center"&gt;&lt;strong&gt;Half&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: center"&gt;3.3V inverted&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;td style="text-align: center"&gt;1&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Implementation on dsPIC with the MPLAB block for Simulink was successfully used with the implementation below set through the UART Configuration block:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style="text-align: center"&gt;Implementation&lt;/th&gt;
&lt;th style="text-align: center"&gt;Buffer size&lt;/th&gt;
&lt;th style="text-align: center"&gt;Interrupt priority&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;S.BUS Rx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;64&lt;/td&gt;
&lt;td style="text-align: center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S.BUS Tx&lt;/td&gt;
&lt;td style="text-align: center"&gt;None&lt;/td&gt;
&lt;td style="text-align: center"&gt;-&lt;/td&gt;
&lt;td style="text-align: center"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart Port Rx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;32&lt;/td&gt;
&lt;td style="text-align: center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart Port Tx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;32&lt;/td&gt;
&lt;td style="text-align: center"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F.Port Rx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;32&lt;/td&gt;
&lt;td style="text-align: center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F.Port Tx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;64&lt;/td&gt;
&lt;td style="text-align: center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="connecting-sbus-smart-port-and-fport-simulink-blocks-to-uart-rx--tx"&gt;Connecting S.BUS, Smart Port and F.Port simulink blocks to UART Rx &amp;amp; Tx&lt;/h3&gt;
&lt;p&gt;S.Bus, F.Port and Smart Port xxx takes receiver output stream to extract control values sent by the remote. The input stream is a vector which length is defined by end user. All values of the vector do not have to be set. The block use the N input length scalar to know how many bytes from the input vector are received values and must be processed. The block input vector can received partial data packet. The whole receiver packet can be sliced over time and sent as values are received by the MCU ; these blocks reconstruct the packet before processing it.&lt;/p&gt;
&lt;h2 id="sbus-protocol"&gt;S.BUS protocol&lt;/h2&gt;
&lt;p&gt;UART Configuration:&lt;/p&gt;
&lt;p&gt;Only Rx channel is used with the following parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;100 000 bauds/s&lt;/li&gt;
&lt;li&gt;Rx inverted logic (Idle state is low level), 3.3V&lt;/li&gt;
&lt;li&gt;Even parity&lt;/li&gt;
&lt;li&gt;2 stop bits&lt;/li&gt;
&lt;li&gt;No control flow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rx is implemented with a Circular Buffer with 64 bytes buffer and interrupt priority 5.&lt;/p&gt;
&lt;p&gt;UART Rx block is sampled at 1kHz (1ms).
Vector output size set to &amp;ldquo;inherited via internal rule&amp;rdquo; is given a value of 10 (no more than 10 bytes can be received in 1 ms at 100000 bauds/s with two stop bits)&lt;/p&gt;
&lt;p&gt;The S.BUS block GUI allows to set which block output shoudl be decoded and the scaling for each channels decoded.&lt;/p&gt;
&lt;div class="box" style="max-width:40%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-sbus-gui-control-frame.png" loading="lazy" alt="This simulink block decode S.BUS input stream. Scaling for output RC channels can be selected for each channels."/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-sbus-gui-control-frame.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;Simulink S.BUS block user interface&lt;/h4&gt;
&lt;p&gt;This simulink block decode S.BUS input stream. Scaling for output RC channels can be selected for each channels.&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="box" style="max-width:100%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-sbus-scheme-uart-connection.png" loading="lazy" alt="Scheme to decode S.BUS for use in a dsPIC"/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-sbus-scheme-uart-connection.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;Scheme of the UART Rx block connected to the S.BUS block.&lt;/h4&gt;
&lt;p&gt;Scheme to decode S.BUS for use in a dsPIC&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="box" style="max-width:100%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-sbus-sport-channels-scaling.png" loading="lazy" alt="raw values from S.BUS are not centered and scaled with power of 2."/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-sbus-sport-channels-scaling.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;Scheme to center and scale S.BUS channels output within [-1000 1000]&lt;/h4&gt;
&lt;p&gt;raw values from S.BUS are not centered and scaled with power of 2.&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;h2 id="smart-port-protocol"&gt;Smart Port protocol&lt;/h2&gt;
&lt;p&gt;Smart Port (S.Port) use UART where Rx and Tx pins are set on the same pin with inverted logic (1 is high level). One single wire is used in half duplex communication mode.&lt;/p&gt;
&lt;p&gt;UART configuration setting:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;57600 bauds/s&lt;/li&gt;
&lt;li&gt;Half duplex&lt;/li&gt;
&lt;li&gt;Rx and Tx inverted logic (Idle state is low level), 3.3V&lt;/li&gt;
&lt;li&gt;No parity&lt;/li&gt;
&lt;li&gt;1 stop bit&lt;/li&gt;
&lt;li&gt;No control flow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implementation:&lt;/p&gt;
&lt;p&gt;Rx is implemented with a Circular Buffer with 32 bytes buffer and interrupt priority 5.&lt;br&gt;
Tx is implemented with a circular buffer with 32 bytes buffer and interrupt priority 6.&lt;/p&gt;
&lt;p&gt;The Smart port block decode inputs from the receiver and from other sensors connected to the one wire bus.&lt;/p&gt;
&lt;p&gt;If a sensor frame is received, it is decoded and values are available at the block output.&lt;/p&gt;
&lt;p&gt;When a receiver request for one sensor Id is received and if this sensor Id is set in one of the sensor block of the model, then the Smart port block generates the sensor frame with the latest values set in the sensor block.
The message is sent through an UART Tx block.&lt;/p&gt;
&lt;h2 id="fport-protocol"&gt;F.Port protocol&lt;/h2&gt;
&lt;div class="box" style="max-width:40%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-fport-gui-control-frame.png" loading="lazy" /&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-fport-gui-control-frame.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="box" style="max-width:80%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-fport-scheme-uart-connection.png" loading="lazy" /&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-fport-scheme-uart-connection.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="gallery caption-position-bottom caption-effect-slide hover-effect-zoom hover-transition" itemscope itemtype="http://schema.org/ImageGallery"&gt;
&lt;div class="box" &gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img" style="background-image: url('/img/uxv-block-rc-pwm-gui.png');"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-rc-pwm-gui.png" loading="lazy" alt="caption"/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-rc-pwm-gui.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;Title&lt;/h4&gt;
&lt;p&gt;caption&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="box" &gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img" style="background-image: url('/img/uxv-block-rc-pwm-input-scaling.png');"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-rc-pwm-input-scaling.png" loading="lazy" alt="caption"/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-rc-pwm-input-scaling.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;title&lt;/h4&gt;
&lt;p&gt;caption&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;UART configuration:
Rx and Tx channels are used. They are assigned to the same pin. UART is configured for to half duplex.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;115200 bauds/s&lt;/li&gt;
&lt;li&gt;Half duplex&lt;/li&gt;
&lt;li&gt;Rx and Tx inverted logic (Idle state is low level), 3.3V&lt;/li&gt;
&lt;li&gt;No parity&lt;/li&gt;
&lt;li&gt;1 stop bit&lt;/li&gt;
&lt;li&gt;No control flow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rx is implemented with a Circular Buffer with 32 bytes buffer and interrupt priority 5.&lt;/p&gt;
&lt;p&gt;Tx is implemented with a circular buffer with 64 bytes buffer and interrupt priority 5.&lt;/p&gt;
&lt;h3 id="ressources"&gt;Ressources&lt;/h3&gt;
&lt;p&gt;FrSky protocol are not always documented. The following website helped understanding the various protocol:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.robotmaker.eu/home/quadcopters-360-degree-proximity-sensing-project-overview/frsky-s-port-interface" target="_blank" rel="noopener"&gt;Smart Port on ROBOTmaker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.google.com/archive/p/telemetry-convert/wikis/FrSkySPortProtocol.wiki" target="_blank" rel="noopener"&gt;Smart Port on telemetry-convert project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/yaapu/FrskyTelemetryScript/wiki/FrSky-SPort-protocol-specs" target="_blank" rel="noopener"&gt;Smart Port TelemetryScript by Allesandro Apostoli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/bolderflight/SBUS" target="_blank" rel="noopener"&gt;S.BUS on Arduino lib project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/athertop/MavLink_FrSkySPort/wiki" target="_blank" rel="noopener"&gt;Smart Port on MavLink-FrSkySPort project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/betaflight/betaflight/tree/master/src/main/telemetry" target="_blank" rel="noopener"&gt;betaflight source code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ardupilot.org/copter/docs/common-frsky-passthrough.html" target="_blank" rel="noopener"&gt;ArduCopter project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://sbustelemetrysensors.blogspot.com/" target="_blank" rel="noopener"&gt;SBUS2 by Jerry Chapman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Received Signal Strength Indicator&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description></item><item><title>block Sensor</title><link>https://lubin.kerhuel.eu/uxv/block-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lubin.kerhuel.eu/uxv/block-sensor/</guid><description>&lt;!-- Enable Photo Swipe + gallery features --&gt;
&lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.css" integrity="sha384-yX+tSqQp3yF8BiTuLLOwNyaqtmZ9yFQT7IYg7U9YU9Dz/JDlh6JJQmNClCmvYl+b" crossorigin="anonymous"&gt;
&lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css" integrity="sha384-R6P/wJIrxjHcm//YCjb0S6rRgebsNn3u6U4NxVI8R03iSPAR5CwPqoq1n6U/tjFE" crossorigin="anonymous"&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.js" integrity="sha384-jkeJ/ETDRD/P4Y3I3CQi1QIwrEJjR9GdAZV2/aqDwwgA5ldCNiExYJeBwKyQC/+q" crossorigin="anonymous"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe-ui-default.min.js" integrity="sha384-HotcxRWS6/oszHPwknjGnd066fV8+ycnO5TXDcOscFWvTtaiCtEEv+9s5Qrn1iJD" crossorigin="anonymous"&gt;&lt;/script&gt;
&lt;div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"&gt;
&lt;div class="pswp__bg"&gt;&lt;/div&gt;
&lt;div class="pswp__scroll-wrap"&gt;
&lt;div class="pswp__container"&gt;
&lt;div class="pswp__item"&gt;&lt;/div&gt;
&lt;div class="pswp__item"&gt;&lt;/div&gt;
&lt;div class="pswp__item"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="pswp__ui pswp__ui--hidden"&gt;
&lt;div class="pswp__top-bar"&gt;
&lt;div class="pswp__counter"&gt;&lt;/div&gt;
&lt;button class="pswp__button pswp__button--close" title="Close (Esc)"&gt;&lt;/button&gt;
&lt;button class="pswp__button pswp__button--share" title="Share"&gt;&lt;/button&gt;
&lt;button class="pswp__button pswp__button--fs" title="Toggle fullscreen"&gt;&lt;/button&gt;
&lt;button class="pswp__button pswp__button--zoom" title="Zoom in/out"&gt;&lt;/button&gt;
&lt;div class="pswp__preloader"&gt;
&lt;div class="pswp__preloader__icn"&gt;
&lt;div class="pswp__preloader__cut"&gt;
&lt;div class="pswp__preloader__donut"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"&gt;
&lt;div class="pswp__share-tooltip"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"&gt;
&lt;/button&gt;
&lt;button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"&gt;
&lt;/button&gt;
&lt;div class="pswp__caption"&gt;
&lt;div class="pswp__caption__center"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The block adds a sensor &amp;ldquo;packet&amp;rdquo; to be transmitted to a receiver through the Smart Port of the F.Port. The receiver send the telemetry packet to the Remote controller (RC). Thus the Simulink should have either a Smart Port or a F.Port block.&lt;/p&gt;
&lt;p&gt;Each sensor block declare the sensor reference composed of the two parameters PhysId and {Address+Offset}. Sensor value is composed of 4 bytes array block input. Multiple instance of the sensor block can be added in a model. Two instance can have the same sensor reference which is used for sensor sending multiple packets with various values (see FrSky FVLSS or GPS sensor).&lt;/p&gt;
&lt;p&gt;Each block instance add a 4 bytes buffer to store the sensor value which is updated at block execution time. The block sample rate defines the update rate of the internal buffer.&lt;/p&gt;
&lt;p&gt;The behaviour vary between Smart Port and F.Port protocol:&lt;/p&gt;
&lt;h3 id="behaviour-with-smart-port"&gt;behaviour with Smart Port&lt;/h3&gt;
&lt;p&gt;The receiver ping the electronics connected on Smart Port for one sensor reference. When a given sensor is ping, it must reply by providing its 4 bytes values within 3ms.&lt;/p&gt;
&lt;p&gt;If more than one instance of the sensor block address the same sensor reference (PhysId, Address+Offset), each blocks data packet are sent one after another.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If a specific sensor Id is ping twice with his (none of his when multiple) block beeing updated in between, the same content is sent again.&lt;/li&gt;
&lt;li&gt;If a sensor block is updated while its previous content has not been sent yet, the block update has no effect and the newer value is lost.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="behaviour-with-fport"&gt;behaviour with F.Port&lt;/h3&gt;
&lt;p&gt;The unique controller connected to the F.Port send a sensor value each RC channel packet received. The sensor to be send depends only on the controller which might send any sensor.&lt;/p&gt;
&lt;p&gt;Each sensor block update add the sensor in a FIFO queue list of sensor request to send.
Only one request for each sensor block instance can be present in this FIFO.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If a sensor block is updated while its previous value has not been sent yet ; this block sensor request to send is still in the FIFO, then the update has no effect and the newer value is lost.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unlike the Smart Port, a sensor cannot be sent twice without having been updated once first because the sensor is placed in the send request FIFO while being updated.&lt;/p&gt;
&lt;p&gt;for its corresponding sensor
The block update sample rate is selected by end user. whose value will be sent to the receiver. The receiver send then the sensor Id and the corresponding values to the remote through telemetry.&lt;/p&gt;
&lt;p&gt;Communication with the receiver can use either the Smart Port, or the F.Port.&lt;/p&gt;
&lt;p&gt;The sensor PhyId, APPID and APPID Offset variant are set within the block.
The PRIM field must be set to 0X10 for a sensor. The sensor value unit is set within the block.
Block input is the 4 bytes coding for the sensor value.&lt;/p&gt;</description></item></channel></rss>
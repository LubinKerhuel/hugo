<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Receiver-Telemetry | Rapid Control Prototyping</title><link>https://lubin.kerhuel.eu/tag/receiver-telemetry/</link><atom:link href="https://lubin.kerhuel.eu/tag/receiver-telemetry/index.xml" rel="self" type="application/rss+xml"/><description>Receiver-Telemetry</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><image><url>https://lubin.kerhuel.eu/media/icon_hu_7804b255830ce5f.png</url><title>Receiver-Telemetry</title><link>https://lubin.kerhuel.eu/tag/receiver-telemetry/</link></image><item><title>block receiver &amp; telemetry: S.BUS, Smart Port, F.Port</title><link>https://lubin.kerhuel.eu/uxv/block-receiver-telemetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lubin.kerhuel.eu/uxv/block-receiver-telemetry/</guid><description>&lt;!-- Enable Photo Swipe + gallery features --&gt;
&lt;p&gt;Three blocks add support for three protocol found in receivers. Traditional PWM output receiver can be handled directly through the Input Capture or Change Notification peripheral and do not required a specific block.&lt;/p&gt;
&lt;h2 id="sbus-smart-port-and-fport"&gt;S.BUS, Smart Port and F.Port&lt;/h2&gt;
&lt;p&gt;S.BUS, Smart Port (also named S.Port) and F.Port are three protocol available in FrSky RC receiver and compatible. All three protocol rely on the UART peripheral with different settings. Their purpose is specific:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S.BUS&lt;/strong&gt; is a unidirectional protocol from the receiver to an external device to provide channels values and RSSI&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt; (i.e. radio link quality).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smart Port (S.Port)&lt;/strong&gt; is a bidirectional protocol. The receiver ping for various connected sensors and retrieve measurements to send through telemetry to the remote control.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F.Port&lt;/strong&gt; is a bidirectional protocol where the receiver communicate channels values and RSSI, and get values from connected sensors to send through telemetry to the remote control.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The two bidirectional protocol &lt;em&gt;Smart Port&lt;/em&gt; and &lt;em&gt;F.Port&lt;/em&gt; use one single wire for Tx and Rx. Communication is done in Half duplex mode.&lt;/p&gt;
&lt;p&gt;FrSky receiver have two variants: (model shipped with Smart port: x4r, rx4r, x6r, s6r, rx6r, x8r, s8r, xsr, xsr-m, r-xsr &amp;hellip;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;S.Bus &amp;amp; Smart Port&lt;/strong&gt; (stock), available on two distinct three pins ports&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F.Port&lt;/strong&gt; available on one replaced Smart Port three pin port&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Stock receiver have two ports: S.BUS and Smart Port. This is changed for a unique F.Port by flashing an alternative firmware provided by &lt;a href="https://www.frsky-rc.com/" target="_blank" rel="noopener"&gt;FrSky&lt;/a&gt;. The alternative firmware remove the S.BUS port and convert the Smart Port to an F.Port.&lt;/p&gt;
&lt;h3 id="uart-settings-and-implementation"&gt;UART settings and implementation&lt;/h3&gt;
&lt;p&gt;S.BUS, S.Port and F.Port have different UART setting defined in the table:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style="text-align: center"&gt;Baudrate&lt;/th&gt;
&lt;th style="text-align: center"&gt;Duplex&lt;/th&gt;
&lt;th style="text-align: center"&gt;Logic&lt;/th&gt;
&lt;th style="text-align: center"&gt;parity&lt;/th&gt;
&lt;th style="text-align: center"&gt;stop-bit&lt;/th&gt;
&lt;th style="text-align: center"&gt;flow-ctrl&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;S.BUS&lt;/td&gt;
&lt;td style="text-align: center"&gt;100000&lt;/td&gt;
&lt;td style="text-align: center"&gt;Rx only&lt;/td&gt;
&lt;td style="text-align: center"&gt;3.3V inverted&lt;/td&gt;
&lt;td style="text-align: center"&gt;even&lt;/td&gt;
&lt;td style="text-align: center"&gt;2&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart Port&lt;/td&gt;
&lt;td style="text-align: center"&gt;57600&lt;/td&gt;
&lt;td style="text-align: center"&gt;&lt;strong&gt;Half&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: center"&gt;3.3V inverted&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;td style="text-align: center"&gt;1&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F.Port&lt;/td&gt;
&lt;td style="text-align: center"&gt;115200&lt;/td&gt;
&lt;td style="text-align: center"&gt;&lt;strong&gt;Half&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: center"&gt;3.3V inverted&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;td style="text-align: center"&gt;1&lt;/td&gt;
&lt;td style="text-align: center"&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Implementation on dsPIC with the MPLAB block for Simulink was successfully used with the implementation below set through the UART Configuration block:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style="text-align: center"&gt;Implementation&lt;/th&gt;
&lt;th style="text-align: center"&gt;Buffer size&lt;/th&gt;
&lt;th style="text-align: center"&gt;Interrupt priority&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;S.BUS Rx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;64&lt;/td&gt;
&lt;td style="text-align: center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S.BUS Tx&lt;/td&gt;
&lt;td style="text-align: center"&gt;None&lt;/td&gt;
&lt;td style="text-align: center"&gt;-&lt;/td&gt;
&lt;td style="text-align: center"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart Port Rx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;32&lt;/td&gt;
&lt;td style="text-align: center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart Port Tx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;32&lt;/td&gt;
&lt;td style="text-align: center"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F.Port Rx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;32&lt;/td&gt;
&lt;td style="text-align: center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F.Port Tx&lt;/td&gt;
&lt;td style="text-align: center"&gt;Circular Buffer&lt;/td&gt;
&lt;td style="text-align: center"&gt;64&lt;/td&gt;
&lt;td style="text-align: center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="connecting-sbus-smart-port-and-fport-simulink-blocks-to-uart-rx--tx"&gt;Connecting S.BUS, Smart Port and F.Port simulink blocks to UART Rx &amp;amp; Tx&lt;/h3&gt;
&lt;p&gt;S.Bus, F.Port and Smart Port xxx takes receiver output stream to extract control values sent by the remote. The input stream is a vector which length is defined by end user. All values of the vector do not have to be set. The block use the N input length scalar to know how many bytes from the input vector are received values and must be processed. The block input vector can received partial data packet. The whole receiver packet can be sliced over time and sent as values are received by the MCU ; these blocks reconstruct the packet before processing it.&lt;/p&gt;
&lt;h2 id="sbus-protocol"&gt;S.BUS protocol&lt;/h2&gt;
&lt;p&gt;UART Configuration:&lt;/p&gt;
&lt;p&gt;Only Rx channel is used with the following parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;100 000 bauds/s&lt;/li&gt;
&lt;li&gt;Rx inverted logic (Idle state is low level), 3.3V&lt;/li&gt;
&lt;li&gt;Even parity&lt;/li&gt;
&lt;li&gt;2 stop bits&lt;/li&gt;
&lt;li&gt;No control flow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rx is implemented with a Circular Buffer with 64 bytes buffer and interrupt priority 5.&lt;/p&gt;
&lt;p&gt;UART Rx block is sampled at 1kHz (1ms).
Vector output size set to &amp;ldquo;inherited via internal rule&amp;rdquo; is given a value of 10 (no more than 10 bytes can be received in 1 ms at 100000 bauds/s with two stop bits)&lt;/p&gt;
&lt;p&gt;The S.BUS block GUI allows to set which block output shoudl be decoded and the scaling for each channels decoded.&lt;/p&gt;
&lt;div class="box" style="max-width:40%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-sbus-gui-control-frame.png" loading="lazy" alt="This simulink block decode S.BUS input stream. Scaling for output RC channels can be selected for each channels."/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-sbus-gui-control-frame.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;Simulink S.BUS block user interface&lt;/h4&gt;
&lt;p&gt;This simulink block decode S.BUS input stream. Scaling for output RC channels can be selected for each channels.&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="box" style="max-width:100%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-sbus-scheme-uart-connection.png" loading="lazy" alt="Scheme to decode S.BUS for use in a dsPIC"/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-sbus-scheme-uart-connection.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;Scheme of the UART Rx block connected to the the S.BUS block.&lt;/h4&gt;
&lt;p&gt;Scheme to decode S.BUS for use in a dsPIC&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="box" style="max-width:100%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-sbus-sport-channels-scaling.png" loading="lazy" alt="raw values from S.BUS are not centered and scaled with power of 2."/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-sbus-sport-channels-scaling.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;Scheme to center and scale S.BUS channels output within [-1000 1000]&lt;/h4&gt;
&lt;p&gt;raw values from S.BUS are not centered and scaled with power of 2.&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;h2 id="smart-port-protocol"&gt;Smart Port protocol&lt;/h2&gt;
&lt;p&gt;Smart Port (S.Port) use UART where Rx and Tx pins are set on the same pin with inverted logic (1 is high level). One single wire is used in half duplex communication mode.&lt;/p&gt;
&lt;p&gt;UART configuration setting:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;56700 bauds/s&lt;/li&gt;
&lt;li&gt;Half duplex&lt;/li&gt;
&lt;li&gt;Rx and Tx inverted logic (Idle state is low level), 3.3V&lt;/li&gt;
&lt;li&gt;No parity&lt;/li&gt;
&lt;li&gt;1 stop bit&lt;/li&gt;
&lt;li&gt;No control flow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implementation:&lt;/p&gt;
&lt;p&gt;Rx is implemented with a Circular Buffer with 32 bytes buffer and interrupt priority 5.&lt;br&gt;
Tx is implemented with a circular buffer with 32 bytes buffer and interrupt priority 6.&lt;/p&gt;
&lt;p&gt;The Smart port block decode inputs from the receiver and from other sensors connected to the one wire bus.&lt;/p&gt;
&lt;p&gt;If a sensor frame is received, it is decoded and values are available at the block output.&lt;/p&gt;
&lt;p&gt;When a receiver request for one sensor Id is received and if this sensor Id is set in one of the sensor block of the model, then the Smart port block generates the sensor frame with the latest values set in the sensor block.
The message is sent through an UART Tx block.&lt;/p&gt;
&lt;h2 id="fport-protocol"&gt;F.Port protocol&lt;/h2&gt;
&lt;div class="box" style="max-width:40%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-fport-gui-control-frame.png" loading="lazy" /&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-fport-gui-control-frame.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="box" style="max-width:80%"&gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-fport-scheme-uart-connection.png" loading="lazy" /&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-fport-scheme-uart-connection.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="gallery caption-position-bottom caption-effect-slide hover-effect-zoom hover-transition" itemscope itemtype="http://schema.org/ImageGallery"&gt;
&lt;div class="box" &gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img" style="background-image: url('/img/uxv-block-rc-pwm-gui.png');"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-rc-pwm-gui.png" loading="lazy" alt="caption"/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-rc-pwm-gui.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;Title&lt;/h4&gt;
&lt;p&gt;caption&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class="box" &gt;
&lt;figure itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"&gt;
&lt;div class="img" style="background-image: url('/img/uxv-block-rc-pwm-input-scaling.png');"&gt;
&lt;img itemprop="thumbnail" src="https://lubin.kerhuel.eu/img/uxv-block-rc-pwm-input-scaling.png" loading="lazy" alt="caption"/&gt;
&lt;/div&gt;
&lt;a href="https://lubin.kerhuel.eu/img/uxv-block-rc-pwm-input-scaling.png" itemprop="contentUrl"&gt;&lt;/a&gt;
&lt;figcaption data-pre="Figure " data-post=":" class="numbered"&gt;&lt;h4&gt;title&lt;/h4&gt;
&lt;p&gt;caption&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;UART configuration:
Rx and Tx channels are used. They are assigned to the same pin. UART is configured for to half duplex.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;115200 bauds/s&lt;/li&gt;
&lt;li&gt;Half duplex&lt;/li&gt;
&lt;li&gt;Rx and Tx inverted logic (Idle state is low level), 3.3V&lt;/li&gt;
&lt;li&gt;No parity&lt;/li&gt;
&lt;li&gt;1 stop bit&lt;/li&gt;
&lt;li&gt;No control flow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rx is implemented with a Circular Buffer with 32 bytes buffer and interrupt priority 5.&lt;/p&gt;
&lt;p&gt;Tx is implemented with a circular buffer with 64 bytes buffer and interrupt priority 5.&lt;/p&gt;
&lt;h3 id="ressources"&gt;Ressources&lt;/h3&gt;
&lt;p&gt;FrSky protocol are not always documented. The following website helped understanding the various protocol:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.robotmaker.eu/home/quadcopters-360-degree-proximity-sensing-project-overview/frsky-s-port-interface" target="_blank" rel="noopener"&gt;Smart Port on ROBOTmaker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.google.com/archive/p/telemetry-convert/wikis/FrSkySPortProtocol.wiki" target="_blank" rel="noopener"&gt;Smart Port on telemetry-convert project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/yaapu/FrskyTelemetryScript/wiki/FrSky-SPort-protocol-specs" target="_blank" rel="noopener"&gt;Smart Port TelemetryScript by Allesandro Apostoli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/bolderflight/SBUS" target="_blank" rel="noopener"&gt;S.BUS on Arduino lib project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/athertop/MavLink_FrSkySPort/wiki" target="_blank" rel="noopener"&gt;Smart Port on MavLink-FrSkySPort project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/betaflight/betaflight/tree/master/src/main/telemetry" target="_blank" rel="noopener"&gt;betaflight source code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ardupilot.org/copter/docs/common-frsky-passthrough.html" target="_blank" rel="noopener"&gt;ArduCopter project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://sbustelemetrysensors.blogspot.com/" target="_blank" rel="noopener"&gt;SBUS2 by Jerry Chapman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Received Signal Strength Indicator&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description></item></channel></rss>